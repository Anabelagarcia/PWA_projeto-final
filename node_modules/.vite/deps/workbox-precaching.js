import {
  PrecacheController,
  PrecacheStrategy,
  getOrCreatePrecacheController,
  matchPrecache
} from "./chunk-V7SEQ6GZ.js";
import "./chunk-JR2DZ4RE.js";
import {
  Route,
  registerRoute
} from "./chunk-NVKJ7VJZ.js";
import {
  cacheNames
} from "./chunk-C6OCUJR7.js";
import {
  getFriendlyURL,
  logger
} from "./chunk-CH2VUBAX.js";

// node_modules/workbox-precaching/addPlugins.js
function addPlugins(plugins) {
  const precacheController = getOrCreatePrecacheController();
  precacheController.strategy.plugins.push(...plugins);
}

// node_modules/workbox-precaching/utils/removeIgnoredSearchParams.js
function removeIgnoredSearchParams(urlObject, ignoreURLParametersMatching = []) {
  for (const paramName of [...urlObject.searchParams.keys()]) {
    if (ignoreURLParametersMatching.some((regExp) => regExp.test(paramName))) {
      urlObject.searchParams.delete(paramName);
    }
  }
  return urlObject;
}

// node_modules/workbox-precaching/utils/generateURLVariations.js
function* generateURLVariations(url, { ignoreURLParametersMatching = [/^utm_/, /^fbclid$/], directoryIndex = "index.html", cleanURLs = true, urlManipulation } = {}) {
  const urlObject = new URL(url, location.href);
  urlObject.hash = "";
  yield urlObject.href;
  const urlWithoutIgnoredParams = removeIgnoredSearchParams(urlObject, ignoreURLParametersMatching);
  yield urlWithoutIgnoredParams.href;
  if (directoryIndex && urlWithoutIgnoredParams.pathname.endsWith("/")) {
    const directoryURL = new URL(urlWithoutIgnoredParams.href);
    directoryURL.pathname += directoryIndex;
    yield directoryURL.href;
  }
  if (cleanURLs) {
    const cleanURL = new URL(urlWithoutIgnoredParams.href);
    cleanURL.pathname += ".html";
    yield cleanURL.href;
  }
  if (urlManipulation) {
    const additionalURLs = urlManipulation({ url: urlObject });
    for (const urlToAttempt of additionalURLs) {
      yield urlToAttempt.href;
    }
  }
}

// node_modules/workbox-precaching/PrecacheRoute.js
var PrecacheRoute = class extends Route {
  /**
   * @param {PrecacheController} precacheController A `PrecacheController`
   * instance used to both match requests and respond to fetch events.
   * @param {Object} [options] Options to control how requests are matched
   * against the list of precached URLs.
   * @param {string} [options.directoryIndex=index.html] The `directoryIndex` will
   * check cache entries for a URLs ending with '/' to see if there is a hit when
   * appending the `directoryIndex` value.
   * @param {Array<RegExp>} [options.ignoreURLParametersMatching=[/^utm_/, /^fbclid$/]] An
   * array of regex's to remove search params when looking for a cache match.
   * @param {boolean} [options.cleanURLs=true] The `cleanURLs` option will
   * check the cache for the URL with a `.html` added to the end of the end.
   * @param {workbox-precaching~urlManipulation} [options.urlManipulation]
   * This is a function that should take a URL and return an array of
   * alternative URLs that should be checked for precache matches.
   */
  constructor(precacheController, options) {
    const match = ({ request }) => {
      const urlsToCacheKeys = precacheController.getURLsToCacheKeys();
      for (const possibleURL of generateURLVariations(request.url, options)) {
        const cacheKey = urlsToCacheKeys.get(possibleURL);
        if (cacheKey) {
          const integrity = precacheController.getIntegrityForCacheKey(cacheKey);
          return { cacheKey, integrity };
        }
      }
      if (true) {
        logger.debug(`Precaching did not find a match for ` + getFriendlyURL(request.url));
      }
      return;
    };
    super(match, precacheController.strategy);
  }
};

// node_modules/workbox-precaching/addRoute.js
function addRoute(options) {
  const precacheController = getOrCreatePrecacheController();
  const precacheRoute = new PrecacheRoute(precacheController, options);
  registerRoute(precacheRoute);
}

// node_modules/workbox-precaching/utils/deleteOutdatedCaches.js
var SUBSTRING_TO_FIND = "-precache-";
var deleteOutdatedCaches = async (currentPrecacheName, substringToFind = SUBSTRING_TO_FIND) => {
  const cacheNames2 = await self.caches.keys();
  const cacheNamesToDelete = cacheNames2.filter((cacheName) => {
    return cacheName.includes(substringToFind) && cacheName.includes(self.registration.scope) && cacheName !== currentPrecacheName;
  });
  await Promise.all(cacheNamesToDelete.map((cacheName) => self.caches.delete(cacheName)));
  return cacheNamesToDelete;
};

// node_modules/workbox-precaching/cleanupOutdatedCaches.js
function cleanupOutdatedCaches() {
  self.addEventListener("activate", (event) => {
    const cacheName = cacheNames.getPrecacheName();
    event.waitUntil(deleteOutdatedCaches(cacheName).then((cachesDeleted) => {
      if (true) {
        if (cachesDeleted.length > 0) {
          logger.log(`The following out-of-date precaches were cleaned up automatically:`, cachesDeleted);
        }
      }
    }));
  });
}

// node_modules/workbox-precaching/createHandlerBoundToURL.js
function createHandlerBoundToURL(url) {
  const precacheController = getOrCreatePrecacheController();
  return precacheController.createHandlerBoundToURL(url);
}

// node_modules/workbox-precaching/getCacheKeyForURL.js
function getCacheKeyForURL(url) {
  const precacheController = getOrCreatePrecacheController();
  return precacheController.getCacheKeyForURL(url);
}

// node_modules/workbox-precaching/precache.js
function precache(entries) {
  const precacheController = getOrCreatePrecacheController();
  precacheController.precache(entries);
}

// node_modules/workbox-precaching/precacheAndRoute.js
function precacheAndRoute(entries, options) {
  precache(entries);
  addRoute(options);
}

// node_modules/workbox-precaching/PrecacheFallbackPlugin.js
var PrecacheFallbackPlugin = class {
  /**
   * Constructs a new PrecacheFallbackPlugin with the associated fallbackURL.
   *
   * @param {Object} config
   * @param {string} config.fallbackURL A precached URL to use as the fallback
   *     if the associated strategy can't generate a response.
   * @param {PrecacheController} [config.precacheController] An optional
   *     PrecacheController instance. If not provided, the default
   *     PrecacheController will be used.
   */
  constructor({ fallbackURL, precacheController }) {
    this.handlerDidError = () => this._precacheController.matchPrecache(this._fallbackURL);
    this._fallbackURL = fallbackURL;
    this._precacheController = precacheController || getOrCreatePrecacheController();
  }
};
export {
  PrecacheController,
  PrecacheFallbackPlugin,
  PrecacheRoute,
  PrecacheStrategy,
  addPlugins,
  addRoute,
  cleanupOutdatedCaches,
  createHandlerBoundToURL,
  getCacheKeyForURL,
  matchPrecache,
  precache,
  precacheAndRoute
};
//# sourceMappingURL=workbox-precaching.js.map
